# Gray Code Encoder Fixes - October 12, 2025

## Summary
Fixed two critical issues with the rudder encoder disk generation that caused incorrect track ordering and bit polarity.

## Issues Fixed

### Issue 1: Track Order Reversal (MSB/LSB)
**Problem**: Tracks were ordered with MSB (Most Significant Bit) on the outermost track, which is backwards from standard Gray code encoder convention.

**Expected**: 
- Track 0 (outermost) = LSB (Least Significant Bit) - Most frequent changes
- Track N-1 (innermost) = MSB (Most Significant Bit) - Least frequent changes

**Why This Matters**:
- Fast-changing bits (LSB) on outer tracks = longer physical arc segments = easier optical detection
- Slow-changing bits (MSB) on inner tracks work well despite shorter circumference because they have long angular spans
- This is the standard convention used in commercial optical encoders (as shown in IMG_8886.jpg reference)

**Root Cause**: 
The `gray_code_bits()` function was returning bits in `[MSB, ..., LSB]` order using `reversed(range(num_bits))`.

**Fix Applied**:
Changed `gray_code_bits()` to return bits in `[LSB, ..., MSB]` order by removing the `reversed()` call.

```python
# BEFORE (incorrect):
return [(gray_value >> i) & 1 for i in reversed(range(num_bits))]

# AFTER (correct):
return [(gray_value >> i) & 1 for i in range(num_bits)]
```

### Issue 2: Bit Polarity Inversion (Open vs. Closed)
**Problem**: Cutouts were being created for '0' bits instead of '1' bits, inverting the entire pattern.

**Expected** (transmissive encoder):
- '1' bit = Light passes through = CUTOUT/OPEN area
- '0' bit = Light blocked = SOLID material

**Why This Matters**:
- The encoder uses transmissive optical sensing (LED on one side, photodetector on other)
- Standard convention: '1' = true = light passes = cutout
- Inverted polarity means sensors would read inverse of actual position

**Root Cause**:
The `generate_track_cutouts()` method was creating cutouts when `bit_value == 0`.

**Fix Applied**:
Changed the cutout logic to create openings for '1' bits.

```python
# BEFORE (incorrect):
if bit_value == 0:  # Create cutout for 0
    # create cutout...

# AFTER (correct):
if bit_value == 1:  # Create cutout for 1
    # create cutout...
```

## Files Modified

### Source Code Changes
1. **src/gray_code/converter.py**
   - Modified `gray_code_bits()`: Removed `reversed()` to return `[LSB, ..., MSB]`
   - Updated `extract_track_pattern()` documentation to clarify track ordering
   
2. **src/geometry/track_generator.py**
   - Changed cutout generation from `bit_value == 0` to `bit_value == 1`
   - Updated comments to document LSB/MSB track positions
   - Added transmissive encoder convention documentation

3. **src/gray_code/validator.py**
   - Updated track descriptions: Track 0 = LSB/outermost, Track N-1 = MSB/innermost

### Test Updates
4. **tests/test_gray_code.py**
   - Updated `test_gray_code_bits_extraction()` expectations for new bit order
   - Updated `test_extract_track_pattern()` to verify LSB on Track 0, MSB on Track 1
   - Added detailed comments explaining bit patterns

### Documentation Updates
5. **docs/ARCHITECTURE.md**
   - Updated Track Layout Strategy section with correct LSB/MSB convention
   - Added Bit Convention section explaining transmissive encoder standards
   - Added FIXED issues section documenting these corrections
   - Clarified why this ordering is optimal for optical detection

## Verification

### Tests
All existing tests pass with updated expectations:
```
tests/test_gray_code.py ......... [100%]  ✅
tests/test_geometry.py .......... [100%]  ✅
```

### Verification Script
Created `verify_fixes.py` demonstrating:
- ✅ Bit order: LSB first (index 0), MSB last (index N-1)
- ✅ Track order: Track 0 has most transitions (LSB), Track N-1 has least (MSB)
- ✅ Bit polarity: '1' = cutout, '0' = solid
- ✅ Transition frequency decreases from outer to inner tracks

### Example: 8 Positions (3 bits)
```
Position:  0  1  2  3  4  5  6  7
Track 0 (LSB, outermost):  0  1  1  0  0  1  1  0  | 4 transitions ✅
Track 1 (mid, middle):     0  0  1  1  1  1  0  0  | 2 transitions
Track 2 (MSB, innermost):  0  0  0  0  1  1  1  1  | 1 transitions ✅
```

## Impact

### Before Fixes
- ❌ Outermost track had least transitions (MSB) - harder to detect
- ❌ Innermost track had most transitions (LSB) - shortest segments
- ❌ Cutouts inverted - sensors would read wrong values
- ❌ Pattern didn't match IMG_8886.jpg reference

### After Fixes
- ✅ Outermost track has most transitions (LSB) - easiest to detect
- ✅ Innermost track has least transitions (MSB) - longer angular spans
- ✅ Cutouts correct - '1' bits are open, '0' bits are solid
- ✅ Pattern matches standard Gray code encoder convention
- ✅ Matches IMG_8886.jpg reference encoder

## Testing Recommendations

1. **Generate Test Disk**: 
   ```bash
   make generate
   ```

2. **Visual Inspection**: 
   - Open generated SCAD file in OpenSCAD
   - Verify outermost track has most cutouts/transitions
   - Verify innermost track has fewer, longer segments
   - Compare to IMG_8886.jpg reference

3. **Physical Test**:
   - Print the corrected disk
   - Verify optical sensors can read all tracks
   - Test against known positions
   - Confirm Gray code sequence matches position

## Notes

- The warning about single-position zero runs on Track 0 is expected for 32-position encoders
- Track 0 (LSB) will always have the most transitions - this is correct behavior
- The fixes maintain 100% encoding efficiency (32 positions = 2^5 = 5 tracks)

## Conclusion

Both critical issues have been resolved:
1. ✅ Track ordering now follows standard convention (LSB outermost, MSB innermost)
2. ✅ Bit polarity now matches transmissive encoder standard ('1' = cutout)

The generated encoder disks will now match standard Gray code encoder design and should work correctly with optical sensing hardware.
